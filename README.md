ГЛАВА 1 - МУЗЫКАЛЬНЫЙ ПОРТАЛ
----------------------------------------------------------------
ЧАСТЬ 1 - НАЧАЛЬНАЯ УСТАНОВКА ( ИСПОЛЬЗУЕТСЯ ДОКЕР, В 16 ЧАСТИ ИНСТРУКЦИЯ ПО РАБОТЕ С PIPENV БЕЗ ДОКЕРА)!
----------------------------------------------------------------
1. Создается проект и application
2. Для Postgre устанавливается адаптер базы данных -> pipenv install psycopg2-binary
3. В корне создаются два файла для докера - Dockerfile и docker-compose.yml
4. Сервер останавливается и запускается консоль - > в корень проекта -> docker-compose up -d(для сохранения возможности работы при включенном сервере) --build(сразу в одну строку и build контейнера)
5. В проекте в settings устанавливается database PostgreSQL
6. Изначальная установка проекта + докер + база данных настроены.

----------------------------------------------------------------
ЧАСТЬ 2 - ИЗМЕНЕНИЕ стандратной модели юзера Джанго
-----------------------------------------------------------------
1. Создаем новый app для аккаунтов юзеров через докер -> docker-compose exec web python manage.py startapp accounts
2. В созданном app в моделях создаётся новая модель, которая будет расширять функционал базы
3. В settings регистрируется новый app И в самом низу пишется AUTH_USER_MODEL = 'accounts.CustomUser', которая будет заменять дефолтные значения
Makemigrations и migrate в консоли докера.
4. В accounts создается forms.py в котором будет созданы формы для расширения дефолтных настроек аккаунта и для новых аккаунтов.
5. в accounts/admin.py добавляется новая модель юзера и формы для представления в админке.
6. Создаем суперюзера docker-compose exec web python manage.py createsuperuser
7. Для проверки правильной настройки на данном этапе в accounts/tests выполним проверку. Так как дефолтные настройки были изменены, на данном этапе следует это сделать. docker-compose exec web python manage.py test
8. Не забываем коммит и пуш в гит периодически.
9. На данном этапе мы изменили стандартную регистрацию и изменение форм для новых аккаунтов, в моделях создан CustomUser к которому можно добавлять новые поля. Также все отображается в админке

-----------------------------------------------------------------
ЧАСТЬ 3 - СОЗДАНИЕ СТРАНИЦ САЙТА
-----------------------------------------------------------------
1. Создаем новый app -> docker-compose exec web python manage.py startapp pages . Регистрация в settings
2. в корне -> папка templates -> создание базового шаблона base.html и создание новой папки pages в которой будет home.html
3. В данном проекте будет использоваться Bootstrap 5 -> docker-compose exec web pipenv install django-bootstrap-v5 . В settings регистрация
4. в pipfile вручную регистрация в packages -> django-bootstrap-v5 = "*", Тут возможно автоматом добавиться, docker-compose down и docker-compose up -d --build
5. Создание нового urls файла в pages app И его include из корневого url проекта. В нем первый path -> home
6. создание нового класса представление во views.py и отображение в нем созданного шаблона home.html
7. на данном этапе создан app для отображения страниц, базовый шаблон, главная страница.

------------------------------------------------------------------
ЧАСТЬ 4 - РЕГИСТРАЦИЯ ЮЗЕРА
------------------------------------------------------------------
1. В проекте в файле url создается новый path для манипуляций с авторизацией и регистрацией юзеров
2. в шаблоне base.html в навбаре указывается jinja2 метод {% if user.is_authenticated %}
3. Джанго имеет встроенные пути для манипуляций с учётной записью - accounts/ -> login, logout, password_change,password_reset. Если в шаблоне при нажатии на кнопку указать путь 'accounts/logout', то юзер автоматически выйдет из учетной записи. Для login уже нужно будет создать шаблон.
4. Для аторизации пользователей нужна форма для ввода данных и шаблон внутри которого она будет храниться -> в templates создается папка registration, а в ней login.html. Папка registration является служебной, из нее автоматически(без прямой установки path в url) будут браться шаблоны, также со служебными именами.
5. Так как используется бутстрап, то хорошим дополнением к формам будет установка пакета - docker-compose exec web pip install crispy-bootstrap5 и регистрация зависимостей в settings. CRISPY_ALLOWED_TEMPLATE_PACKS = "bootstrap5" CRISPY_TEMPLATE_PACK = "bootstrap5". Не забывать прописывать их в pipfile.
6. Затем необходимо указать редирект при логине и логауте юзера, для этого в settings - LOGIN_REDIRECT_URL = 'home' LOGOUT_REDIRECT_URL = 'home'
7. В accounts app создаем urls.py. В нем будет прописан путь для регистрации пользователей signup. Также он include в корневом url
8. В accounts views создается класс для представления регистрации. В нем указана расширенная форма, шаблон и редирект при успешной регистрации.
9. В templates/registration/ создается шаблон signup.html для предоставления страницы при регистрации нового пользователя, также в base.html создается новая кнопка для регистрации, при нажатии на которую юзер автоматически попадает на созданный шаблон.
10. Желательно провести тесты для устранения больших проблем на позднем этапе. accounts/test.py
11. На данном этапе регистрация и авторизация юзера успешно созданы и протестированы. Регистрация берется из расширенной модели формы.
----------------------------------------------------------------
ДОП.МАТЕРИАЛ ПО VUE.JS 
----------------------------------------------------------------
1. В файле base.html внизу страницы создан код для правильного отображения данных из vue.js . На заметку! Также помнить про AJAX для джанго.гуглить.
-----------------------------------------------------------------
ЧАСТЬ 5 - ДОБАВЛЕНИЕ СТАТИКИ 
-----------------------------------------------------------------
1. В settings добавляется несколько строчек кода для правильного поиска для статических файлов в локальном виде и на продакшне.
2. В корне создается папка static и в ней css/js/images.
3. В base.html на самом верху указывается {% load static %} для загрузки всех статических файлов во всех шаблонах.
4. Для отображения изображения в шаблонах указывается тэг {% static 'images/name.jpg' %} 
5. Для использования js в скриптах указывается script src="{% static 'js/base.js' %}"><script>
6. Создадим еще одну страницу в pages app, она будет называться about. Создается шаблон, url, view, также прописываются ссылки из навбара.
7. В конце добавим тесты в pages  
8. В этой части мы добавили статические изображения, возможность использования js/vue кода и создали новую страницу about, также проверив всё тестами.
------------------------------------------------------------------
ЧАСТЬ 6 - ПРОДВИНУТАЯ РЕГИСТРАЦИЯ ЮЗЕРА / DJANGO ALLAUTH
------------------------------------------------------------------
1. Если после перерыва нам снова нужно запустить наш проект через докер - docker-compose up -d --build, после этого в контейнер будут загружен проект и все зависимости через pipfile и проект будет отображен по localhost.
2. Затем устанавливаем библиотеку для расширения представления регистрации юзера - docker-compose exec web pipenv install django-allauth, если использовать обычный pip,а не pipenv, то зависимости придется прописывать вручную. Через pipenv прописывается автоматом в Pipfile.
3. Затем сервер докера останавливается docker-compose down, и собирается заново docker-compose up -d --build. Так как появились новые библиотеки и проект нужно собрать заново.
4. затем необходимо прописать в settings.py новый установленный пакет 'allauth' и 'allauth.account'. Также укажем SITE_ID = 1 внизу.
5. Затем прописывается много строчек кода под новую библиотеку в файле settings.py, в основном заменяются дефолтные настройки и расширяется подкапотный функционал. Также меняются настройки редиректа при логине/логауте.
6. После внесенных настроек в setting.py нужно произвести миграцию docker-compose exec web python manage.py migrate
7. Затем в корневом urls.py меняется путь для user-management и удаляется строчка для регистрации в local-apps
8. Новая библиотека также будет смотреть на шаблоны представлений для регистрации и авторизации в папке templates, как и в дефолтных настройках. Но! дефолтные настройки смотрели в папку templates/registration/... . Django-allauth смотрит в папку templates/account/... . Так что создаем данную папку и переносим ранее созданные login.html и signup.html в неё. Папка registration более не нужна. Удалить!
9. Осталось поменять urls в ранее созданных файлах в путях шаблона _base.html. В ранее созданых путях {% url 'login'/logout/signup %} нужно подставить префикс 'account_ {% url 'account_signup' %}
10. Затем нужно создать новый шаблон для функции logout ->  templates/account/logout.html и немного поменять форму в actions.
11. В файле settings.py есть много настроек для логина/регистрации паользователя. Комментарии добавлены. Проверяем регистрацию, всё ли работает.
12. Тесты.
13. Allauth увеличил функционал регистрации и авторизации юзера, также добавив анимационные вставки при операции. Также можно использовать аккаунты из других популярных сайтов, гайд тут - https://django-allauth.readthedocs.io/en/latest/providers.html?highlight=naver.
14. Также в будущем в админке понадобится доступ к имени сайта - > для этого нужно прописать в settings в установленных приложениях -> 'django.contrib.sites',
15. Хорошая статья - https://russianblogs.com/article/6833594772/ . Показывает как подсоединить авторизацию через сервисы такие как гитхаб,гугл,эппл и много нужных вещей.
16. Сделаем авторизацию через vk. зарегистрируем в settings -> 'allauth.socialaccount','allauth.socialaccount.providers.vk'. В шаблоне templates/accounts/login.html пропишем тэги для провайдера. Там уже всё готово. После этого нужно сделать migrate. Затем заходим на сайт https://dev.vk.com/ и авторизуемся. В меню мои приложения - создаем новое приложение. Вводим название, указываем сайт и вводим адрес сайта - http://127.0.0.1, в домене тоже http://127.0.0.1. На деплое меняется. Затем заходим в админку и видим новые поля - нам нужно социальные приложения. Провайдер - vk, имя - vk , id клиента из настроек [https://dev.vk.com/ю](https://vk.com/editapp?id=8178496&section=options). Идва ключа по порядку. Также нужно перенести сайт в правую колонку. Теперь авторизация через вк доступна.
-----------------------------------------------------------------
ЧАСТЬ 7 - ФУНКЦИИ БЕЗОПАСНОСТИ
-----------------------------------------------------------------
1. Устанавливается пакет для усиленной защиты, в котором будут спрятаны секретные данные, такие как ключи проекта. docker-compose exec web pipenv install 'environs[django]'. После успешной установки пакета, docker-compose down и docker-compose -d --build.
2. Затем в settings.py импортируется from environs import Env, и прописывются две строчки пакета -> env = Env() , nv.read_env().
3. в docker-compose.yml прописывается новая строчка с секретным ключом. И в settings ключ прячится SECRET_KEY = env("DJANGO_SECRET_KEY"). Если секретный ключ будет содержать знак доллара $, то нужно поставить еще один такой знак, иначе будет ошибка - особенности докера.
4. Debug = True видим ошибки для разработчика. Спрячим его в env -> DEBUG = env.bool("DJANGO_DEBUG") и в docker-compose.yml -> 
5. В allowed host необходимо указать доступные для работы хосты - ALLOWED_HOSTS = ['community.pythonanywhere.com', 'localhost', '127.0.0.1']. Меняются в зависимости от конечного хостинга на котором будет распологаться сайт + локальный хост для работы.
6. Также спрячем базу данных в settings.py -> DATABASES = {
    "default": env.dj_db_url("DATABASE_URL", default="postgres://postgres@db/postgres")
}
7. На данном этапе благодаря установленный библиотеке environs, основные данные спрятаны в docker-compose.yml, который впоследствии также будет спрятан)))
-----------------------------------------------------------------
ЧАСТЬ 8 - ОТПРАВКА ПИСЕМ С САЙТА
-----------------------------------------------------------------
1. При успешной регистрации пользователя ему отправляется письмо с подтверждением его действий и приветствием на сайте! Используется библиотека allauth для такого функционала и чтобы изменить изначальный текст необходимо переписать несколько файлов.
2. Создадим два новых файла в папке templates/account/email/email_confirmation_subject.txt и templates/account/email/email_confirmation_message.txt и в них изменим изначальный текст нужный нам. Тут еще не забыть сделать migrate.
3. В админ панели будет указана строчка sites - в ней указанный шаблон example.com изменим на нужный нам.
4. Внизу settings укажем строчку -> DEFAULT_FROM_EMAIL = 'admin@djangomusic.com'
5. Теперь пользователю будет отправлено сообщение от указанного email и с новым названием сайта. Но пока что только в логах :)
6. При отправке пользователю сообщения ему также будет предоставлена ссылка для подтверждения при переходе по которой он получит шаблон страницы с подтверждением.
	Для красивого отображения нового шаблона его нужно создать в месте где распологаются все allauth шаблоны -> templates/account/email_confirm.html. Шаблон будет 	   отличаться от предыдущих, так что взять из репозитория.
7. Также для будущих манипуляций с аккаунтом, стоит сразу добавить два шаблона c путями url -> templates/accounts/password/reset/  -> templates/accounts/password/change/ и accounts/password/reset/done/. Подробнее по ссылке - https://russianblogs.com/article/6833594772/.
8. После созданных шаблонов как пример подключаемся к внешнему smtp серверу smtp.mail.ru. В settings указываем порт,хост и юзера. Пример в файле. Для аналогов почтовых сервисов по ссылке - https://vivazzi.pro/ru/it/send-email-in-django/
9. В данном разделе полностью настроена работа с почтовым клиентом для сброса/восстановления пароля.
-----------------------------------------------------------------
ЧАСТЬ 9 - Добавление списка обьектов, определенный обьект, защищенный URL, удаление и создание базы данных.
-----------------------------------------------------------------
1. Создадим новый app docker-compose exec web python manage.py startapp music. И зарегистрируем его в settings.
2. Далее в новом приложении music/models.py создадим новую модель данных. docker-compose exec web manage.py makemigrations и migrate. Регистрация в админке.
3. СОздается новый url файл в приложении,а в корневом url указывается include.
4. В файле views создается новое представление для отображения данных в модели -> ListView 
5. Затем создается шаблон для представления в templates/music/music_list.html и происходит отображение всех обьектов в модели music.
6. Если можно посмотреть все модели,то значит можно и определенную. Для этого создается новый url с <int:pk> в music/urls и во views используется DetailView. Для перехода к определенному обьекту из списка всех альбомов, создается кнопка с ссылкой {% url 'music_detail' m.pk %}. Тут в качестве pk используется уникальный ключ обьекта. Впоследствии лучше использовать slug, так как он более гибок в названии, можно использовать и строчки и цифры.
7. Также принято использовать get_absolute_url для получения определеннго обьекта. В модели music импортируется reverse и используется у модели Music в качестве метода. При использования slug, код будет отличаться, смотреть в  репозитории Django-Books. После добавления реверса меняются ссылки в шаблонах с {% url 'music_detail' m.pk %} на {{ m.get_absolute_url }}. Данный метод более гибок,так как позволяет смотреть обьект из админки и обладает более защищенным от ошибок отображением обьекта. Юзать его.
8. ЧИТАТЬ НИЖЕ!!!Также для лучшей защиты от хакерских атак лучше использовать - uuid. В моделях импортируется uuid и прописывается в поле id с параметрами. В music/urls меняется путь на <uuid:pk>. База данных была изменена и в данной ситуации единственный выход это удалить базу с музыкой docker-compose exec web rm -r music/migrations -> docker compose down. Для проверки созданных баз -> docker volume ls. Так как использовать postgre нужно будет удалить архив docker volume rm music_postgres_data -> docker-compose up -d -> docker compose exec web python manage.py makemigrations music -> docker compose exec web python manage.py migrate -> docker compose exec web python manage.py createsuperuser. В данном случае мы удалили полностью базу данных и пользователей и создали заново. Продумать базу лучше заранее во избежании подобных ситуаций! UUID по опыту использования добавляет много проблем с 3rd party пакетами, так что по возможности лучше его не и пользовать.Слаг юрл в помощь.
9. Для использования слага необходимо в модели Music указать новое поле slug, изменить get_absolute_url и изменить url путь в music/urls
10. В данном разделе мы расширили функционал сайта списком композиций и одной определенной, добавили защищенные пути URL и заново собрали базу данных после критических изменений.
-----------------------------------------------------------------
!!!!АРХИВ!!!ЧАСТЬ 10 - FOREIGN KEYS RELATIONSHIP, РЕЦЕНЗИИ ПОЛЬЗОВАТЕЛЕЙ К АЛЬБОМАМ. В АРХИВ!!! ЧАСТЬ 19 ПЕРЕДЕЛАНО!
-----------------------------------------------------------------
1. Создадим возможность пользователям оставлять свои рецензии к альбомам. Для этого в ранее созданом music app создадим новую модель, в которой поле album будет связано с моделью Music и поле author будет автоматически использоваться для авторизованного пользователя. app docker-compose exec web python manage.py makemigrations music -> docker-compose exec web python manage.py migrate
2. Затем в админке music/admin прописывается TabularInline класс для основной модели Music, для того чтобы отображение рецензий было сразу видно из модели Music в админке. Для теста создадим юзера и через админку пропишем несколько рецензий для будущего их отображения.
3. На данном этапе создана связь между одним альбомом и рецензиями к ней. Чтобы отобразить данные рецензии к альбому в шаблоне перейдем в music_detail.html и в нужном месте пропишем цикл for, который будет брать рецензии из music.reviews.all(т.е из альбома берутся все рецензии через related name(имзмененное имя)) и затем отображаются также как в обычном цикле.
4. В будущем в этот раздел еше добавится инструкция по добавлению своих рецензий через форму. Возможно через Vue.
-----------------------------------------------------------------
ЧАСТЬ 11 - Загрузка собственных изображений на сайт
-----------------------------------------------------------------
1. Для возможности загрузки пользовательских изображений и файлов нам необходимо установить библиотеку pillow -> docker-compose exec web pipenv install pillow -> docker-compose down -> docker-compose up -d --build.
2. Затем в settings добавим две строчки MEDIA_URL -> MEDIA_ROOT и создадим новую попку в корне проекта media и в ней media/covers.
3. В файле config/urls импортируется два модуля и пишется строчка кода с загрузкой статики. В файле пометка # images.
4. Для загрузки изображений нужно добавить соответствующее поле в модель Music. Для изображений ImageField, для обычных файлов - FileField. Затем docker-compose exec web python manage.py makemigrations music -> docker-compose exec web python manage.py migrate
5. Теперь если зайди в админку и попробовать загрузить изображение, то оно автоматически загрузится в проект в ранее созданную папку media/covers
6. Чтобы отобразить изображение в шаблоне необходимо для src указать => src="{{ music.cover.url }}. И сделаем защиту от альбомов у которых нету изображения условием if music.cover. Также для новых картинок можно установить ссылку по нажатию через ранее созданный get_absolute_url.
7. В будущем добавим возможность добавлять свои альбомы и загружать свои изображения через форму, смотрим в Django_books.
-----------------------------------------------------------------
ЧАСТЬ 12 - Добавление альбомов пользователем
-----------------------------------------------------------------
1. Чтобы пользователь мог добавлять свои собственные альбомы, необходимо создать форму для этого. Начнем с установки библиотеки docker-compose exec web pipenv install django-simple-captcha. Добавляем в setting в 3rd party app и делаем перестройку контейнера docker-compose down -> docker-compose up -d --build. Также необходимо сделать миграцию. Также не забыть в корне path('captcha/', include('captcha.urls')). Подробно по этой библиотеке https://django-simple-captcha.readthedocs.io/en/latest/advanced.html. Капча нужна. Защиты прибавляет.
2. Затем создаем форму в music/forms.py и прописываем путь для отображения новой формы в urls.
3. Во views импортируем CreateView, добавляем к классу форму и reverse_lazy. Также добавим миксин что только авторизованный пользователь может добавлять альбомы иначе доступ будет запрещен.
4. Создаем новый шаблон templates/music/add_music.html, добавляем новую форму и проверяем.
5. Также в данном разделе можно еще сделать отображение более удобных для пользователя отображение ошибок, таких как доступ запрещен и страница не найдена. Для этого в корневом urls пропишем handler403 = authNeed, данные хэндлеры будут обработчиками событий ошибок и направлять на нужный шаблон с сообщением. Из music.views будет импортирована функция authNeed в которой будет происходить обработка ошибок и содержаться шаблон для показа.
-----------------------------------------------------------------
ЧАСТЬ 13 - Миксины для доступа к CRUD только определенным пользователям.
-----------------------------------------------------------------
1. На данном этапе любой пользователь может добавлять альбомы, независимо авторизирован он или нет. Надо это исправить. Для начала в music/views импортируем LoginRequiredMixin, который будет давать доступ для просмотра и добавления альбомов только авторизованным пользователям.
2. Затем данный миксин добавляется к классам в которых мы хотим поставить запрет на посещение страница. В данной ситуации запрет будет указан у всех трех ранее созданных классов. При функциональных представлениях используются декораторы. В нашем случае миксины.
3. Также необходимо поставить редирект для класса после успешного запрета. Можно использовать success_url или login_url в которых будет указан шаблон для редиректа. Reverse_lazy для редиректа в последнюю очередь после успешной обработки всех остальных событий.
4. Затем создадим в админке нового пользователя. Здесь также можно указать свою группу с разрешениями для определенных пользователей. Но в целях обучения создадим свои собственные. Для этого в модели Music необходимо указать класс Meta, в котором мы создадим новое разрешение и оно отобразится в разрешениях пользователя в админке, также надо сделать миграции.
5. Теперь в view импортируем новый миксин, который запрашивает разрешение и применим его к DetailView. Теперь пользователь без данного разрешения не сможет смотреть детально альбом. Но если ему это разрешение предоставить через админку, то просмотр будет разрешен.
6. Также в будущем для более глубокого изучения разрешенного доступа можно погуглить Добавление пользователей в определенные группы со своими разрешениями, например премиум-аккаунты. Также присутствуют еще один популярный миксин UserPassesTestMixin.
-----------------------------------------------------------------
ЧАСТЬ 13 - ПОИСК В БАЗЕ И ПОКАЗ РЕЗУЛЬТАТА В ШАБЛОНЕ.
-----------------------------------------------------------------
1. Для создания поиска нам необходимо создать view/url/template для показа результата. Начнем с создания url в music/urls, затем создадим новый класс представления который будет иметь ListView и шаблон для показа результатов search_results.html. Весь этап аналогичен простому представлению обьектов в модели через for.
2. Основа есть, queryset = Music.objects.filter(title__icontains='Bell') дефолтный ListView будет изменен и станет показыватьь только обьекты у которых title имеет строку Bell. Но нам нужно чтобы пользовательский поиск выдавал нужный результат. Для этого в home.html пропишем новую форму, в котором будет находиться input. И после того как Пользователь ввел нужный ему текст будет выдаваться результат. Во view меняется queryset.
3. Django-watson и django-haystack предлагают более расширенные настройки для работы с поиском, по необходимости гуглить.
-----------------------------------------------------------------
ЧАСТЬ 14 - ОПТИМИЗАЦИЯ РАБОТЫ САЙТА, PERFOMANCE. Cache, Index.
-----------------------------------------------------------------
1. Для начала оптимизации сайта необходимо установить библиотеку docker-compose exec web pipenv install django-debug-toolbar и затем остановить контейнер docker-compose down. После установки надо зарегистрировать установленную библиотеку в settings -> debug_toolbar. Также необходимо внести изменения в настройку MIDDLEWARE - > смотреть в файле setting. И третья настройка - INTERNAL_IPS, если докер не используется то указать INTERNAL_IPS = '127.0.0.1', в случае использования докера необходимо ипортировать библиотеку socket и написать две строчки кода -> смотреть в файл. После данных манипуляций тулбар готов к использованию -> docker-compose up -d --build.
Также, чтобы тулбар показывался только в DEBUG = True методе нужно прописать строчку в корневом url.
2. Затем добавим кэш. У джанго есть встроенная функция для кэширования, также как альтернатива присутствуют библиотеки Memcached и django-redis. Самый удобный способ кэша, это добавления в settings кода, который будет указывать где кэш будет храниться, затем в нужном шаблон загружается {% load cache %} и нужный нам фрагмент кода который не меняется оборачивается тэгом {% cache 20 sidebar %} -> Где cache указание функции, 20 -> время кэша -> sidebar для удобства обозначения оборачиваемого кода.
3. Также для ускорения считывания данных из базы можно применить индексирования для модели. Плюсы - приблизительное ускорение считывания на 25%, минусы - затраты на обьем требуемой памяти в жестком диске увеличиваются. Для этого надо добавить в music/models в модель Music -> db_index = True к полю id или всем другим полям и сделать миграции.
4. Для ускорения работы django ORM также можно использовать 3rd party package - django-extensions. Гуглить.
5. Также для уменьшения размеров статических файлов,таких как изображения могут использоваться такие пакеты как django-compressor и easy-thumbnails.
-----------------------------------------------------------------
ЧАСТЬ 15 - Безопасность.
----------------------------------------------------------------
1. Периодически для джанго выходит обновления безопасности и в целях предотвращения новых способов взлома сайта необходимо делать обновления -> docker compose exec web python -Wa manage.py test, будет запускаться тест для проверки систем безопасности и если будут найдены угрозы, то произойдет обновление.
2. Перед  деплоем на сервер джанго предлагает проверить все ли условия были соблюдены, для этого надо прописать docker compose exec web python manage.py check --deploy и в данном проекте появится 5 проблем, которые необходимо устранить, о них далее.
3. Дальнейшие действия будут использоваться по причине работы с докером. И они будут сильно отличаться от например деплоя сайта без докера на beget. Сперва необходимо создать в корне проекта новый файл docker-compose-prod.yml, скопируем код и сделаем еще один файл .gitignore в который добавим ранее созданный yml.
4. Затем docker-compose down -> docker-compose -f docker-compose-prod.yml up -d --build -> docker-compose exec web python manage.py migrate. Создан и запущен контейнер который непосредственно отвечает за продакшн и изменения для будущего развертывания сайта будут происходить в нем, не затрагивая другой основной контейнер к которому можно вернуться в любой момент.
5. Затем в продакшн контейнер файле изменим Debug с True на False, после этого остановка и запуск контейнера, так как данные были изменены. Также в корневом settings добавим несколько строчек,которые будут защищать сайт от всех возможных угроз.
6. Также для предотвращения взлома панель администратора есть несколько популряных способов. Самый топорный это просто удалить путь к админ панели. Также же можно изменить его имя наприме с host/admin на host/anything-but-admin и стандартные атаки по адресу url будут просто не доходить до адресата. Еще один популярный способ это устновить пакет django-admin-honeypot которая будет генерировать фейковый админ-адрес. Гуглить.
7. После внесенных изменений проводим еще раз проверку на деплой и должно быть без ошибок. Гуглдить докер деплой, в данном руководстве не будет.
-----------------------------------------------------------------
ЧАСТЬ 16 - PIPENV И ПРОДОЛЖЕНИЕ РАБОТЫ С ПРОЕКТОМ БЕЗ ДОКЕРА. Пагинация, авторизация сразу после регистрации. Фильтры для шаблонов. Админка.
-----------------------------------------------------------------
1. Докер показал себя удобным при работе в команде и возможно при деплое, но продолжение проекта будет происходить без него, так как манипуляций он прибавляет,а проект будет расширяться с точки зрения функционала для обучения и будущего применения. Также на время проекта изменим базу данных с Postgre на sqlite. В settings указано.
2. Для этого теперь мы будем работать из IDE с pipenv. Изначально нужно установить в проект все зависимости которые есть в файле pipfile -> pipfile install, затем войти в окружение pipenv -> pipenv shell -> и из данного окружения применять уже привычные для дажнго команды - > python manage.py makemigrations music -> python manage.py migrate -> создадим суперпользователя и добавим альбом. Проверяем что всё работает и поиск не отвалился. Если всё ок, то проект готов к расширению.
3. В accounts/views импортируем пакеты redirect и login. И пропишем код для автоматического логина после регистрации и добавим контекст для title,также проверяем указанную при регистрации почту, должно появиться сообщения с подтверждением регистрации, переходим по ссылке и проверяем правильный алгоритм работы.
4. Добавим пагинацию. Если в ListView наших альбомов будет показано больше чем два альбома,то появится кнопка перехода на следующую страницу. Для этого в music/views в классе представления всех альбом пропишем paginate метод и укажем максимальное количество на странице. Пример отображения в шаблоне указан в templates/music/music_list.html.
5. Также в шаблонах применим фильтры для отображаемой через jinja информации |linebreaks|truncatewords:1, которые можно применить к переменной или сделать обертку {% filter upper %} text {% endfilter %} который сделает весь текст в верхнем регистре в оборачиваемых тэгах. Весь список тут - https://www.djbook.ru/rel1.4/ref/templates/builtins.html
6. Под конец данной части изменим отображения полей в панели админинстратора для более симпатичного отображения и добавим фильтры для поиска music/admin.py
-----------------------------------------------------------------
ЧАСТЬ 17 - Добавление моделей, Пользовательские тэги для отображения любой модели в любом шаблоне, настройка отображения категорий.
-----------------------------------------------------------------
1. Добавим в music/models новую модель Category и сделаем ей ForeignKey для альбомов. Также добавим в ранее созданную форму новое поле и в админку. После этого делаем миграцию. Также будет использован get_absolute_url который будет возвращать ссылку на 'category'/slug:slug/ из будущего url.
2. Затем создадим новую папку в music/templatetags и создадим новые два файла __init__.py и music_tags.py во втором будут содержаться пользовательские тэги, которые можно использовать в любом шаблоне. В данном случае мы напишем тэг для отображения всех доступных категорий. После этого необходимо перезапустить сервер.
3. Затем в шаблоне _base.htm загрузим наши пользовательские тэги {% load music_tags %} и теперь можно отобразить их в шаблоне, например используем {% get_categories as cats %} и в строке где должны быть указаны категории пропишем цикл {% for c in cats %}, которые будут выдавать нам список всех достпуных категорий, а по клику на категорию перенаправлять на шаблон с представлениями всех обьектов по этой категории.
4. Затем добавим в music/urls новую строчку для отображения категорий  path('category/<slug:slug>/', CategoryView.as_view(), name='category')
5. Также для отображения всех альбомов в категории нам нужен свой шаблон, создадим template/music_category.html. В этом шаблоне будет проверка на наличие альбомов в данной категории, затем будет цикл for с моим костыльным решением фильтра |slice который выведет названия нынешней категории только один раз,а не для каждого обьекта.
Далее следует снова цикл for но уже для отображения всех альбомов под данную категорию,также идет проверка на наличие изображения, ссылка на детальное представление альбома через get_absolute_url по клику на название, изображение и кнопку details. Также есть кнопка по нажатию на которую показываются все альбомы в данной категории.
6. И Самое интересное -> работа с music/view, тут подробно. Создадим новый ListView который назовем CategoryView и пропишем для него модель Music, шаблон используем ранее созданный, будет конекстное имя music и применим пагинацию. Затем используем вот такую строчку context['title'] = 'Category - ' + str(context['music'][0].category) для правильного отображения названия категории в title шаблона. Также будет второй контекст context['category'] = Music.objects.filter(category__slug=self.kwargs['slug']).select_related('category') который был ранее использован для отображения категории в шаблоне со |slice . Как альтернатива можно использовать вместо этого пользовательский тэг. Ну и для правильного отображения только нужных нам альбомов подходящих под данную категорию меняется стандартное отображение всех обьектов на get_queryset в котором обьекты будут фильтроваться и показываться только под нужную нам категорию.
7. Также для показа возможностей контекста добавим новую строчку Music.objects.filter(category__slug=self.kwargs['slug']).select_related('category').count() благодаря которой мы сможем показывать количество альбомов в данной категории. В корне проекта присутствует файл DJANGO_ORM.txt в котором показано много методов работы с базой данных для отображения в шаблоне нужной информации.
8. Также для практики возможностей редактирования и удаления альбомов/комментариев добавим новое поле в модель Music -> added_by которая будет ссылаться на юзера который создал данный обьект.
-----------------------------------------------------------------
ЧАСТЬ 18 - Работа с View. Автоматическое добавление слага и юзера в форму. CRUD.
-----------------------------------------------------------------
1. Так как мы используем классовое представление есть несколько полезных вещей о которых надо знать. Например в нашем Listview для представления всех альбомов можно изменить дефолтное отображение обьектов  queryset = Music.objects.all().order_by('-time_create'), в данной случае самый последний альбом будет показан первым. Или например queryset = Book.objects.filter(title__icontains='zeppelin')[:5]  Получение 5 альбомов, содержащих слово 'zeppelin' в заголовке.
2. Во views закомментирован код функционального представления создания формы для добавления альбома. 
3. Также для практики добавим возможность редактировать и удалять сообщения,но только пользователям которые сами их и создали. Для этого создадим два шаблона music/music_edit и music/music_delete. пропишем пути в url. Добавим в шаблон music_detail.html две кнопки со ссылкой на url со слагом обьекта. Во view создадим два класса у которых будет присутствовать миксин UserPassesTest который будет проверять через функцию является ли пользователь который хочет редактировать или удалить сообщение тем же самым человеком который ранее это создал. Также пишется функция в каждом классе для проверки obj.added_by == self.request.user.
4. Чтобы каждый раз не запрашивать поле added_by(user) из формы, можно применить метод form_valid в классе представления AddMusicView. И теперь авторизованный юзер каждый раз автоматически будет добавлятся к конкретному обьекту.
5. Ну и слаг юзеру вводить не очень хочется наверное. Для автоматического добавления слага, сначала проверим что мы его убрали из полей формы и затем для модели Music пропишем метод save, который будет через джанговский пакет slufigy при сохранении формы автоматически создавать слаг для обьекта из названия + автора. 
6. Также в модели Music присутствует поле draft которое является булевым значением и в данном контексте представляет из себя черновик. Если True, то данный альбом еще не закончен и в процессе редактирования. Во views добавим фильтр queryset = Music.objects.all().order_by('-time_create').filter(draft=False). Который не будет отображать черновики в списке альбомов.
7. Также добавим новую модель для нашего альбома AlbumShots, которое будет содержать в себе бутлеги/постеры и будет связано через ключ с основной моделью Music. Миграции и в music_details.html в нужном месте пропишем цикл {% for image in music.albumshots_set.all %} который будет возвращать все постеры для данного альбома.
8. Так как это сайт про музыкальные альбомы, надо добавить по сэмплу песни для определенного альбома. Для этого создадим новую модель для нашего альбома по аналогии с Albumshots и через {% for song in music.albumsong_set.all %} выведем композиции привязанные к альбому.
-----------------------------------------------------------------
ЧАСТЬ 19 - Изменения в базе данных, добавление комментариев к альбому
-----------------------------------------------------------------
1. Изменим модель Reviews и сделаем связь с моделью Music и добавим несколько полей. В musiс/forms создадим новую форму которая будет зависеть от модели Revies и пропишем в нее нужные поля. Также в music/admin изменим отображение Reviews как отдельным столбиком. Создадим новый path в music/url который будет иметь вид -> path('reviews/<int:pk>', AddReview.as_view(), name='add_review') в котором pk будет номер нашего альбома.
2. Затем интереснее -> во Views создадим новый класс AddReview, который будет обрабатывать форму на сайте и сохранять данные в базу. Комментарии добавлены
3. Теперь добавим код в шаблон music/add_music. Тут добавляется поле для отображения всех комментариев к данному обьекту через {% for review in music.reviews_set.all %} и создается форма для заполнения и отправки. Также есть счётчик.
4. Чтобы пользователь не вводил каждый раз свои данные(имя и почту) в шаблоне сделаем поля hidden для почты и имени, которые будут спрятаны от глаз, но в них будет содержаться информация при отправке, которая будет находиться во views -> AddReview, после остановки сохранения для проведения манипуляций пропишем form.name = request.user и form.email = request.user.email. Теперь пользователю нужно будет только ввести комментарий и поля Имя и Почта будут заполнены автоматически из данных при регистрации текущего пользователя.
-----------------------------------------------------------------
ЧАСТЬ 20 - Ответ на комментарии.
-----------------------------------------------------------------
1. Добавим новое скрытое поле к ранее созданой форме в music_detail -> <input type="hidden" name="parent" id="contactparent" value=""> Данный инпут будет родительским комментом. Также к самой форме добавим id="formReview" для дальнейших манипуляций с джс. В скриптах укажем function addReview, которая будет принимать два параметра айди поста к которому будет ответ и айди имени для автоматической вставки имени в поле ввода. во Views к форме применим условие if request.POST.get("parent", None) -> которое будет брать айдишник комментария и добавлять к нему ответы.
2. В модели music создадим новый метод def get_review в котором будет фильтрация по родительскому комментарию, по которому в будущем будет проходить цикл для правильного отображения комментарий->ответ.
3. И затем в music_details.html выполним двойной цикл, первый из которых будет {% for review in music.get_review %} - будет проверять нет ли у данного комментария родителя,значит это основной комментарий. И второй цикл {% for rew in review.reviews_set.all %} - уже будет привязываться к родительским комментариям. 
-----------------------------------------------------------------
ЧАСТЬ 21 - Изменения в админ-панели. Добавление пакета ckeditor
-----------------------------------------------------------------
1. В основном все изменения в админке закомментированы в файле. Тут напишу основные моменты. Вместо обьычный регистрации админ-класса admin.site.register(Category, CategoryAdmin), можно использовать декоратор @admin.register(Category). Добавим TabularInline для наших отзывов, для того чтобы в альбоме они сразу показывались и можно было их модерировать.
2. Для показа миниатюр изображений используем метод get_html_photo. Для вывода нужных нам имен столбиков в apps.py указываем verbose_name = "". Также добавим еще один табулар класс для показа постеров из альбома AlbumShotsInline.
3. Для расширения функционала описания статьи мы установим библиотеку ckeditor https://github.com/django-ckeditor/django-ckeditor, она позволит использовать вордовский функционал прям из админки с автоматическим сохранением в шаблон, но для этого надо будет произвести несколько важных шагов -> для начала установим сам пакет pipenv install django-ckeditor и зарегистрируем его в settings. Затем важный момент! Необходимо закомментировать настройку STATICFILES_DIRS и изменить DEBUG = FALSE
4. Затем необходимо выполнить команду python manage.py collectstatic и дождаться сбора всей статики на сайте. После этого возвращаем Debug = True раскомментируем ранее спрятанную строку STATICFILES_DIRS и закомментируем STATIC_ROOT.												
5. Чтобы файлы можно было загружать на сайт необходимо зарегистрировать еще один пакет ckeditor_uploader в settings. И также в настройках написать строку CKEDITOR_UPLOAD_PATH = "uploads/" для указания куда сохранять файлы. Затем в корневом url нужно прописать path('ckeditor/', include('ckeditor_uploader.urls')),
6. После этого мы заходим в music/admin и импортируем две библиотеки from ckeditor_uploader.widgets import CKEditorUploadingWidget и from django import forms. Затем пишем код из файла, указав нужное поле для виджета и регистрируем данную форму в MusicAdmin -> form = MusicAdminForm. Фух. Писанины много,но оно того стоило, теперь заходим в админку и наслаждаемся. Также для установки всех возможных опций при редактирования текста добавим в settings много кода с настройками. В файле закомментировано.
7. Но это еще не все, для ckeditor существуют плагины для установки доп. опций. Давайте установим плагин для просмотра видео из youtube -> перейдем по ссылке https://ckeditor.com/cke4/addon/youtube и внизу страницы будет кнопка скачать. Затем данный архив нужно распаковать в staticfiles/ckeditor/ckeditor/plugins. И прописать в конфиге ckeditor. Теперь можно давать ссылку на ютюб видео. Многие популярные музыкальные видео с ютюба заблокированы. Гуглить. Возможно пакет django embed video
8. И теперь чтобы можно было использовать редактированный текст из админки нужно в music_details.html прописать наш тэг с описанием из бд и добавить |safe, чтобы отображение правильно отображалось и рендерилось не как тэги, а как полноценные шаблоны. {{ music.description|safe }}. Наш плагин настроен и готов к работе.
9. Также для большего функционала можно использовать admin actions,например для создания больших опций для работы с фильтрами и выбором. В данном проекте они не будут использованы. https://www.youtube.com/watch?v=YsAhxkSGJyg&list=PLF-NY6ldwAWrb6nQcPL21XX_-AmivFAYq&index=16
-----------------------------------------------------------------
ЧАСТЬ 22 - Фильтр по нескольким полям.
-----------------------------------------------------------------
1. Для создания фильтра начнем с создания нового класса в music/views getYearInClass, в данном классе пропишем метод, который будет возвращать отфильрованный список обьектов и только со значением year. Данный класс можно использовать в других классах вместо контекста, например для списка обьектов в MusicListView можно прописать class MusicListView(LoginRequiredMixin, getYearInClass, ListView) и в шаблоне Music.list.html сделать вывод нашего метода из getYearInClass через цикл {% for music in view.get_year %} -> {{ music.year }}.
2. Также добавим еще один метод в данный класс get_category, который будет возвращать список всех категорий. В шаблоне также цикл {% for music in view.get_category %}.
Но в данном инпуте мы должны будем передать значение value="{{ category.id }}" так как это другая модель через связь с ForeignKey.
3. Создадим новый класс для фильтра в music/views FilterMusicView и в get_queryset методе будет логика проверки какие поля были переданы(можно добавлять условиями) т в queryset будет возвращены нужные обьекты по фильтру. 
4. Также в url необходимо прописать path("filter/", FilterMusicView.as_view(), name='filter'), и обязательно чтобы поля со slug были ниже.
5. Также для фильтрации еще используются пакеты django. Гуглить.
-----------------------------------------------------------------
ЧАСТЬ 23 - Добавляем рейтинг к альбому. ДАННАЯ ЧАСТЬ НЕ ДОВЕДЕНА ДО УМА И БУДЕТ ПОЛНОСТЬЮ ПЕРЕДЕЛАНА.
-----------------------------------------------------------------
1. Для начала создадим две новые модели в models/music - > Rating и Ratingstar. И для модели Ratingstar добавим три звезды-обьекта -> 1,2,3,4,5.
2. Далее нужно создать новую форму music/forms -> RatingForm, данная форма будет связана с модель Rating и иметь одно поле star.
3. Затем импортируем данную форму во view и в классе MusicDetailView добавим метод к get_context_data -> context["star_form"] = RatingForm(), также во view добавляем класс AddStarRating.
4. В music_detail.html пишем форму с радио кнопками <form action="{% url 'add_rating' %}" к ней будет подключен css файл для красивого отображения звезд. В url пропишем путь path("add-rating/", AddStarRating.as_view(), name='add_rating')
5. Также пропишем поля для отображения в админке RatingAdmin и добавим scripts.js к base.html.
6. В js файле пропишем интерактив. 
7. Также к контексту в MusicDetailView добавим два новых context["rating_sum"] - будет вести подсчет средней оценки. И context["num_rating"] - количество отзывов. И сделаем вывод данной информации в шаблон по контексту. Комментарии прилагаются. Присутствует проблема с уникальностью рейтинга и уникальным значением. Часть дополняется.
-----------------------------------------------------------------
ЧАСТЬ 24 - Форма обратной связи и сбор информации от пользователя через форму для просмотра в админке.
-----------------------------------------------------------------
1. Также для пользователя необходима форма обратной связи или возможность подписаться на рассылку. Давайте это реализуем.
2. Для начала создадим новый app, который будет полностью независим от проекта, рекомендуется делать много небольших app. Находясь в pipenv shell -> python manage.py startapp contact. Затем в contact/models пропишем новую модель для будущей формы. И в admin.py зарегистрируем новую модель со всеми полями. Также не забываем зарегистрировать в settings.
3. Затем создадим файл contact/forms.py и в данном файле пропишем новую форму. В форме будут указаны поля для ввода - email и message, пользователь и время будут добавлены автоматически. Затем во views пропишем новый класс ContactView, который будет связан с формой и моделью, также передадим метод form_valid, который автоматически будет добавлять юзера.
4. Добавим в url path("", ContactView.as_view(), name="contact"), который будет связан по action с формой из шаблона. И сделаем в корневом url его include.
5. В будушем нашу форму мы хотим видеть на каждой странице сайта в футере. Чтобы данная функция работала с другими страницами необходимо создать папку contact/templatetags и в ней __init__.py и contacttags.py. Пропишем @register.inclusion_tag("contact/tags/form.html") и создадим данный шаблон в templates/contact/tags/form.html.
6. В шаблоне пропишем <form action="{% url 'contact' %}" method="post"> и добавим красивые стили. Используя тэг contact_form мы также можем юзать crispy, не забыть зарегистрировать в шаблоне. 
7. Последний этап это отобразить наш тэг в основном шаблоне _base.html -> {% contact_form %} желательно обернув {% if user.is_authenticated %}.
8. Теперь при отправке сообщения оно будет отображаться в админке.
-----------------------------------------------------------------
ЧАСТЬ 25 - Добавление видеофайлов в режиме хостинга с оптимизацией js.
-----------------------------------------------------------------
Видео в данной части будут независимы от предыдуших альбомов и исполнителей во избежание перегруженности приложения.
1. Установим несколько дополнительных библиотек pipenv install asgiref, pipenv install pytz, pipenv install sqlparse.
1.1 Создаем новый app videoclip, регистрируем его в settings и сразу прописываем в корневом url path('video/', include('videoclip.urls')), регистрируем в админке.
2. Создадим новую модель Video, в будущем лучше использовать slug. В ней будет описание,тайтл,загрузка видео в формате mp4 и картинка.
3. Создадим новый файл services.py в котором будет находиться логика для проигрывателя. Также в url пропишем 3 path. Вместо int:pk лучше slug.
4. Во views пропишем три новых класса. Первый для отображения всех видеофайлов в виде обьектов. Второй для предоставления детального доступа к видеофайлу. И третий который будет содержать необходимую логику и оптимизацию из ранее созданного services.py
5. В _base.html нужно добавить новые скрипты наверху - <script src="{% static 'js/vendor/modernizr-2.6.2.min.js' %}"></script>
    							  <link href="https://vjs.zencdn.net/7.10.2/video-js.css" rel="stylesheet" />
					     внизу - комментарии предоставлены.
6. Создадим два новых шаблона templates/video_hosting/home.html и video.html
7. И самое скучное добавим новые js файлы в static/js - > min,vendor,main,plugins. Готово.
8. Для перенастройки внешнего вида и доп. настраиваемые опции в доке - https://docs.videojs.com/index.html или https://www.youtube.com/watch?v=EIPvq9n4noM
------------------------------------------------------------------------------------------------------------------------------------------------------------------
Доп.Часть по анимации - хорошая настройка https://mdbootstrap.com/docs/b4/jquery/css/animations/, если нужно более тонко с параллаксом и дополнительными возможностями то ставим Pinegrow.
	

ГЛАВА 2 - ФРАНКЕНШЕЙНИМ ДАЛЬШЕ! СОЗДАНИЕ АНАЛОГА МАГАЗИНА С КОРЗИНОЙ И ОПЛАТОЙ.
------------------------------------------------------------------------------------------------------------------------------------------------------------------
В данной главе не будет инструкции по работе так как кода много и он часто будет меняться. Поэтому будет инструкция по пользованию данным app.
--------
На данный момент настроены - Отображение товаров, изображение, название, статус новизны, цена, пагинация, детальное представление товара, возможность добавить и удалить товар из корзины, отображение количества предметов в корзине, поле для скидки, сумма всех товаров, добавление количества плюсом и минусом из корзины и появление сообщений об этом, функция удаления сразу всей позиции и его количества, формы возврата, доставки с запоминающим интерактивом, добавление карты(работает тестовая карта). Отображение большого количества информации в админке.
----------------
Что не так -  купоны не настроены. При удалении товара купон остается и даже если добавить новый товар, он не даст произвести оплату. 
-----------------------------------------------------------------------------------------------------------------------------------------
Пройдемся по коду, идеально будет дойти до варианта с корзиной, с отображением и суммой покупок, купоны лучше не использовать. Если понадобится прикрутить оплату, можно посмотреть в сторону django-sberbank, или продолжить со stripe, но для этого нужно будет зарегистрировать бизнес аккаунт на stripe.com. Вариант с корзиной предполагает что будет отправлена форма в админку и уже будет предоставлена ручная обратная связь с обсуждением оплаты и прочих нюансов доставки. Проект тяжелый для новичка и очень хрупкий в изменениях. Для проекта установлены 3 библиотеки 'django_countries',"corsheaders",'stripe', в основном нужны только если понадобится онлайн оплата. С вариантом с корзиной можно без них. В настройках измнения только в STRIPE_PUBLIC_KEY TRIPE_SECRET_KEY, нужны для онлайн оплаты.
------------------------------------------------------------------------------------------------------------------------------------------
Все нужные шаблоны уже созданы в shop/templates - html/css/js настроены. Также есть изменения в _base.html и используется шаблон из mdb.bootstrap.
В templatestags создан фильтр, который будет использоваться для подсчета количества предметов в корзине на каждой странице в навигации.
Админка настроена на скорую руку, всё выведено для админа, но требует перевода и понятности.
Созданы 4 формы - Нужны только если потребуется производить онайлн оплату.
В моделях и view комментарии по возможности будут предоставлены.
В итоге имеем немного недоработанный онлайн магаз, редактировать тут сложно чтото будет, так как код - высший пилотаж, но позаимствовать некоторые идеи можно.
